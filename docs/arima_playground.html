<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AR Kernel Learning Playground</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        min-height: 100vh;
      }
      .container {
        max-width: 1400px;
        margin: 0 auto;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
      }
      h1 {
        text-align: center;
        margin-bottom: 10px;
        font-size: 2.5em;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }
      .subtitle {
        text-align: center;
        margin-bottom: 30px;
        font-size: 1.1em;
        opacity: 0.9;
      }
      .playground {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        margin-bottom: 30px;
      }
      .panel {
        background: rgba(255, 255, 255, 0.15);
        border-radius: 15px;
        padding: 20px;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }
      .panel h3 {
        margin-top: 0;
        font-size: 1.3em;
        text-align: center;
        margin-bottom: 15px;
      }
      canvas {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 10px;
        display: block;
        margin: 0 auto;
        border: 2px solid rgba(255, 255, 255, 0.3);
      }
      .controls {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
      }
      .control-group {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
      }
      .control {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      .control label {
        font-weight: 600;
        font-size: 0.9em;
      }
      input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        height: 8px;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.3);
        outline: none;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #ffffff;
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      }
      input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #ffffff;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      }
      .preset-buttons {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
        margin-bottom: 15px;
      }
      .preset-btn {
        padding: 8px 16px;
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.4);
        border-radius: 20px;
        color: white;
        cursor: pointer;
        font-size: 0.9em;
        transition: all 0.3s ease;
      }
      .preset-btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
      }
      .metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 15px;
        margin-top: 15px;
      }
      .metric {
        text-align: center;
        background: rgba(0, 0, 0, 0.2);
        padding: 10px;
        border-radius: 10px;
      }
      .metric-value {
        font-size: 1.4em;
        font-weight: bold;
        display: block;
      }
      .metric-label {
        font-size: 0.8em;
        opacity: 0.8;
      }
      .explanation {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
        border-left: 4px solid #ffffff;
      }
      .fullwidth {
        grid-column: 1 / -1;
      }
      .signal-components {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 10px;
        padding: 15px;
        margin-top: 10px;
        font-size: 0.9em;
      }
      .component {
        margin: 5px 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .component-name {
        font-weight: bold;
      }
      .learn-btn {
        background: #4ecdc4;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 1.1em;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        margin: 10px auto;
        display: block;
      }
      .learn-btn:hover {
        background: #45b7b8;
        transform: scale(1.05);
      }
      .kernel-info {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 10px;
        font-size: 0.9em;
      }

      .metric {
        position: relative;
        cursor: help;
        transition: background-color 0.2s ease;
        border-radius: 8px;
        padding: 8px;
      }

      .metric:hover {
        background-color: rgba(255, 255, 255, 0.1);
      }

      .metric[title]:hover::after {
        content: attr(title);
        position: absolute;
        bottom: 120%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 0.8em;
        white-space: nowrap;
        max-width: 250px;
        white-space: normal;
        width: max-content;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .metric[title]:hover::before {
        content: '';
        position: absolute;
        bottom: 110%;
        left: 50%;
        transform: translateX(-50%);
        border: 6px solid transparent;
        border-top-color: rgba(0, 0, 0, 0.9);
        z-index: 1000;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üéØ Interactive Business Forecaster</h1>
      <p class="subtitle">
        Simulate different business environments and see how well our forecasting models adapt to predict revenue
      </p>

      <div class="playground">
        <div class="panel">
          <h3>üìä Simulated Daily Revenue</h3>
          <canvas id="signalCanvas" width="500" height="300"></canvas>
          <div class="signal-components" id="signalComponents">
            <div
              style="text-align: center; font-weight: bold; margin-bottom: 10px"
            >
              Market Factors:
            </div>
          </div>
          <button class="learn-btn" onclick="fitARModel()">
            üîÑ Learn From This History
          </button>
          <div id="viewControls" style="display:none; text-align: center; margin-top: 15px;">
            <div style="display: flex; justify-content: center;">
              <button class="learn-btn" onclick="testGeneralization()" id="testBtn" style="background: #9b59b6; margin: 5px;">
                üß™ See How It Performs Next Quarter
              </button>
            </div>
            <div style="margin-top: 10px; display: flex; justify-content: center; gap: 10px;">
              <button class="preset-btn" onclick="showTrainingView()" id="trainViewBtn">
                üìä Training Data View
              </button>
              <button class="preset-btn" onclick="showTestView()" id="testViewBtn" style="display:none;">
                üß™ Test Data View
              </button>
            </div>
            <div id="currentView" style="margin-top: 5px; font-size: 0.9em; opacity: 0.8;">
              Currently viewing: Training Data
            </div>
            <div style="margin-top: 5px; font-size: 0.8em; opacity: 0.6; font-style: italic;">
              Note: Predictions are visually aligned for clarity - actual forecasts inherently lag by one time step
            </div>
          </div>
        </div>

        <div class="panel">
          <h3>‚ö° The Model's Learned Strategy</h3>
          <canvas id="kernelCanvas" width="500" height="300"></canvas>
          <div class="kernel-info">
            <div class="metric" title="How accurate the model is on training data. Lower is better. This represents the typical squared dollar error.">
              <span class="metric-value" id="mseValue">-</span>
              <span class="metric-label">Forecast Accuracy (Avg. $ Error) üìä</span>
            </div>
            <div class="metric" title="What pattern the model learned: High-pass (recent trends matter most), Low-pass (long-term averages), Band-pass (cyclical patterns)">
              <span class="metric-value" id="kernelType">-</span>
              <span class="metric-label">Model's Focus üîç</span>
            </div>
            <div class="metric" id="genMetric" style="display:none;" title="How accurate the model is on completely new data it has never seen. This tests if the model will work in real business situations.">
              <span class="metric-value" id="genMSE">-</span>
              <span class="metric-label">Real-World Accuracy üåç</span>
            </div>
            <div class="metric" id="ratioMetric" style="display:none;" title="Compares training vs real-world accuracy. Under 1.5 = Good model. Over 2.5 = Overfitted (memorized noise instead of learning patterns).">
              <span class="metric-value" id="overfitRatio">-</span>
              <span class="metric-label">Future-Proof Score üéØ</span>
            </div>
          </div>
        </div>

        <!-- Business Takeaway Box -->
        <div class="panel fullwidth" id="businessTakeaway" style="display:none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; margin: 20px 0;">
          <h3 style="color: white; text-align: center; margin-bottom: 20px;">üí° Business Takeaway</h3>
          <div id="takeawayContent" style="font-size: 1.1em; line-height: 1.6; text-align: center; padding: 20px;">
            <!-- Dynamic content will be inserted here -->
          </div>
        </div>

        <div class="panel fullwidth">
          <h3>üéØ Forecast vs Actual Market Prices</h3>
          <canvas id="predictionCanvas" width="1300" height="280"></canvas>
        </div>

        <div class="panel fullwidth">
          <h3>üìä Forecasting Errors ($ Difference)</h3>
          <canvas id="errorCanvas" width="1300" height="280"></canvas>
        </div>

      </div>

      <div class="controls">
        <h3 style="text-align: center; margin-bottom: 15px">
          Market Scenario Simulator
        </h3>
        <div class="preset-buttons">
          <button class="preset-btn" onclick="setSignalPreset('trend')" title="Simulate a market with steady upward growth - like a successful tech startup or expanding retail chain">
            üìà Trending Market
          </button>
          <button class="preset-btn" onclick="setSignalPreset('cyclical')" title="Simulate regular business cycles - like seasonal retail sales or quarterly earnings patterns">
            üîÑ Business Cycles
          </button>
          <button class="preset-btn" onclick="setSignalPreset('volatility')" title="Simulate periods of high and low market activity - like calm periods followed by busy seasons">
            üìàüìâ Volatility Clustering
          </button>
          <button class="preset-btn" onclick="setSignalPreset('seasonal')" title="Combine long-term growth with seasonal patterns - like a growing business with summer peaks">
            üåä Seasonal + Trend
          </button>
          <button class="preset-btn" onclick="setSignalPreset('arma')" title="Complex market dynamics where recent performance affects future results - like customer loyalty effects">
            üéõÔ∏è ARMA(2,1) Process
          </button>
          <button class="preset-btn" onclick="setSignalPreset('jumps')" title="Market with sudden unexpected events - like viral marketing campaigns or supply chain disruptions">
            ‚ö° Jump Diffusion
          </button>
        </div>

        <div class="control-group">
          <div class="control">
            <label title="How many past days/weeks does the model consider? A shorter memory reacts quickly to new trends, while a longer memory focuses on stable, long-term patterns."
              >Model Memory (Lookback Period): <span id="arOrderValue">8</span></label
            >
            <input
              type="range"
              id="arOrder"
              min="2"
              max="20"
              step="1"
              value="8"
            />
          </div>
          <div class="control">
            <label title="How much historical data to simulate. More data helps the model learn better patterns but takes longer to process.">Signal Length: <span id="lengthValue">200</span></label>
            <input
              type="range"
              id="signalLength"
              min="100"
              max="500"
              step="50"
              value="200"
            />
          </div>
          <div class="control">
            <label title="How much random, day-to-day fluctuation is in the market? High unpredictability makes forecasting harder but more realistic.">Market Unpredictability: <span id="noiseValue">0.1</span></label>
            <input
              type="range"
              id="noiseLevel"
              min="0"
              max="0.5"
              step="0.05"
              value="0.1"
            />
          </div>
          <div class="control">
            <label title="Controls the underlying growth rate of the business. Is it a high-growth startup (high values) or a stable, mature company (low values)?">Market Growth / Decline: <span id="trendValue">0.5</span></label>
            <input
              type="range"
              id="trendStrength"
              min="0"
              max="2"
              step="0.1"
              value="0.5"
            />
          </div>
        </div>

        <div class="control-group">
          <div class="control">
            <label title="Yearly patterns like holiday sales peaks, summer tourism spikes, or back-to-school seasons."
              >Annual Seasonality: <span id="lowFreqValue">0.05</span></label
            >
            <input
              type="range"
              id="lowFreq"
              min="0"
              max="0.2"
              step="0.01"
              value="0.05"
            />
          </div>
          <div class="control">
            <label title="Business quarter effects like end-of-quarter sales pushes, quarterly earnings impacts, or seasonal inventory cycles."
              >Quarterly Patterns: <span id="midFreqValue">0.15</span></label
            >
            <input
              type="range"
              id="midFreq"
              min="0"
              max="0.5"
              step="0.01"
              value="0.15"
            />
          </div>
          <div class="control">
            <label title="Short-term effects like weekend sales spikes, weekly promotions, payroll cycles, or day-of-week patterns."
              >Weekly Noise / Promotions: <span id="highFreqValue">0.4</span></label
            >
            <input
              type="range"
              id="highFreq"
              min="0"
              max="1"
              step="0.05"
              value="0.4"
            />
          </div>
          <div class="control">
            <label title="Mathematical transformation that can help with exponential growth patterns. Usually keep at 0 unless modeling explosive growth scenarios.">Log Component: <span id="logValue">0.0</span></label>
            <input
              type="range"
              id="logComponent"
              min="0"
              max="1"
              step="0.1"
              value="0.0"
            />
          </div>
        </div>
      </div>

      <div class="explanation">
        <h3>üß† What You're Learning About Forecasting:</h3>
        <p>
          <strong>Daily Store Revenue Simulation:</strong> This generates realistic daily sales patterns ($5k-25k range) including seasonal trends, business cycles, promotional effects, and external shocks - just like real retail operations.
        </p>
        <p>
          <strong>Model Training:</strong> The forecasting algorithm learns patterns from historical daily sales - recent revenue trends, seasonal cycles, and mean reversion tendencies.
        </p>
        <p>
          <strong>Business Insight:</strong> Different business conditions (growth periods, seasonal downturns, promotional campaigns) require different forecasting approaches. This is why models need regular retraining as business conditions change!
        </p>
        <p>
          <strong>Overfitting Risk:</strong> A model that's too complex may memorize past noise instead of learning real patterns - it looks great on old data but fails on new market conditions.
        </p>
      </div>
    </div>

    <script>
      // Canvas setup
      const signalCanvas = document.getElementById("signalCanvas");
      const signalCtx = signalCanvas.getContext("2d");
      const kernelCanvas = document.getElementById("kernelCanvas");
      const kernelCtx = kernelCanvas.getContext("2d");
      const predictionCanvas = document.getElementById("predictionCanvas");
      const predictionCtx = predictionCanvas.getContext("2d");
      const errorCanvas = document.getElementById("errorCanvas");
      const errorCtx = errorCanvas.getContext("2d");
      // Removed response canvas - too technical for MBA audience
      // const responseCanvas = document.getElementById("responseCanvas");
      // const responseCtx = responseCanvas.getContext("2d");

      // State
      let signal = [];
      let kernel = [];
      let predictions = [];
      let errors = [];
      let arOrder = 8;
      let signalLength = 200;
      let noiseLevel = 0.1;
      let trendStrength = 0.5;
      let lowFreq = 0.05;
      let midFreq = 0.15;
      let highFreq = 0.4;
      let logComponent = 0.0;
      let signalComponents = [];

      // Signal generation - more realistic market-like behavior
      function generateSignal() {
        signal = [];
        signalComponents = [];

        // Initialize with starting value
        signal.push(0);

        // Random walk component (most important for realistic behavior)
        const walkStrength = 0.3;
        let cumulativeWalk = 0;
        for (let i = 1; i < signalLength; i++) {
          cumulativeWalk += (Math.random() - 0.5) * walkStrength;
          signal.push(cumulativeWalk);
        }
        signalComponents.push({
          name: "Random Walk",
          strength: walkStrength.toFixed(2),
        });

        // Add drift/trend component
        if (trendStrength > 0) {
          for (let i = 0; i < signalLength; i++) {
            // Non-linear trend with some curvature
            const trendValue =
              trendStrength * (i / signalLength) +
              0.2 * trendStrength * Math.pow(i / signalLength, 2);
            signal[i] += trendValue;
          }
          signalComponents.push({
            name: "Drift + Curvature",
            strength: trendStrength.toFixed(2),
          });
        }

        // Add very subtle long-term cycles (much weaker than before)
        if (lowFreq > 0) {
          for (let i = 0; i < signalLength; i++) {
            // Much weaker amplitude and add phase randomness
            const phaseShift = Math.random() * Math.PI;
            const amplitude =
              0.15 * Math.sin(2 * Math.PI * lowFreq * i + phaseShift);
            signal[i] += amplitude;
          }
          signalComponents.push({
            name: "Subtle Long Cycle",
            freq: lowFreq.toFixed(3),
          });
        }

        // Add regime changes (sudden shifts in trend)
        const numRegimes = Math.floor(signalLength / 50);
        for (let r = 0; r < numRegimes; r++) {
          const changePoint = Math.floor(
            ((r + 0.5) * signalLength) / numRegimes
          );
          const shiftMagnitude = (Math.random() - 0.5) * 0.8;
          for (let i = changePoint; i < signalLength; i++) {
            signal[i] += shiftMagnitude * Math.exp(-(i - changePoint) / 20);
          }
        }
        if (numRegimes > 0) {
          signalComponents.push({ name: "Regime Changes", count: numRegimes });
        }

        // Add volatility clustering (periods of high/low volatility)
        let volatilityState = 1.0;
        for (let i = 1; i < signalLength; i++) {
          // Volatility follows its own AR process
          volatilityState =
            0.95 * volatilityState + 0.05 * (Math.random() + 0.5);
          const volatilityNoise =
            (Math.random() - 0.5) * noiseLevel * volatilityState;
          signal[i] += volatilityNoise;
        }
        signalComponents.push({
          name: "Vol Clustering",
          level: noiseLevel.toFixed(2),
        });

        // Add occasional jumps (market shocks)
        const jumpProb = 0.05;
        for (let i = 1; i < signalLength; i++) {
          if (Math.random() < jumpProb) {
            const jumpSize = (Math.random() - 0.5) * 1.5;
            signal[i] += jumpSize;
          }
        }
        signalComponents.push({
          name: "Occasional Jumps",
          prob: jumpProb.toFixed(2),
        });

        // Add very subtle mid-frequency component (much weaker)
        if (midFreq > 0) {
          for (let i = 0; i < signalLength; i++) {
            const amplitude =
              0.08 * Math.sin(2 * Math.PI * midFreq * i + Math.random());
            signal[i] += amplitude;
          }
          signalComponents.push({
            name: "Weak Mid Cycle",
            freq: midFreq.toFixed(3),
          });
        }

        updateSignalDisplay();
      }

      function setSignalPreset(preset) {
        switch (preset) {
          case "trend":
            // Strong upward trending market with random walk
            trendStrength = 1.5;
            lowFreq = 0.01; // Very subtle long cycles
            midFreq = 0.03; // Barely noticeable
            highFreq = 0.0; // No artificial high freq
            logComponent = 0.0;
            noiseLevel = 0.2;
            break;
          case "cyclical":
            // Business cycle dominated (but still mostly random walk)
            trendStrength = 0.3;
            lowFreq = 0.04; // Stronger business cycle
            midFreq = 0.08;
            highFreq = 0.0;
            logComponent = 0.0;
            noiseLevel = 0.15;
            break;
          case "volatility":
            // High volatility periods with clustering
            trendStrength = 0.1;
            lowFreq = 0.0;
            midFreq = 0.0;
            highFreq = 0.0;
            logComponent = 0.0;
            noiseLevel = 0.4; // High noise for vol clustering
            break;
          case "seasonal":
            // More realistic seasonal patterns
            trendStrength = 0.6;
            lowFreq = 0.06; // Annual-like cycles
            midFreq = 0.25; // Quarterly-like
            highFreq = 0.0;
            logComponent = 0.0;
            noiseLevel = 0.12;
            break;
          case "arma":
            // Generate ARMA(2,1) process
            generateARMASignal();
            return;
          case "jumps":
            generateJumpDiffusionSignal();
            return;
        }

        updateSliders();
        generateSignal();
      }

      function generateARMASignal() {
        // ARMA(2,1) with specific coefficients
        const arCoeffs = [0.6, -0.2];
        const maCoeffs = [0.4];

        signal = [];
        const innovations = Array.from(
          { length: signalLength },
          () => (Math.random() - 0.5) * noiseLevel
        );

        // Initialize
        signal.push(innovations[0]);
        signal.push(
          arCoeffs[0] * signal[0] +
            innovations[1] +
            maCoeffs[0] * innovations[0]
        );

        // Generate rest of series
        for (let t = 2; t < signalLength; t++) {
          let value =
            arCoeffs[0] * signal[t - 1] +
            arCoeffs[1] * signal[t - 2] +
            innovations[t];
          if (t > 0) value += maCoeffs[0] * innovations[t - 1];
          signal.push(value);
        }

        signalComponents = [
          { name: "ARMA(2,1) Process", detail: "œÜ‚ÇÅ=0.6, œÜ‚ÇÇ=-0.2, Œ∏‚ÇÅ=0.4" },
          { name: "White Noise", level: noiseLevel.toFixed(2) },
        ];

        updateSignalDisplay();
      }

      function generateJumpDiffusionSignal() {
        signal = [0];
        const dt = 1.0; // Each time step
        const drift = 0.02; // Slight upward drift
        const volatility = 0.25; // Base volatility
        const jumpIntensity = 0.08; // 8% chance per period
        const jumpMean = 0.0;
        const jumpStd = 0.4;

        for (let t = 1; t < signalLength; t++) {
          // Geometric Brownian motion component
          const dW = Math.sqrt(dt) * (Math.random() - 0.5) * 2;
          let dS = drift * dt + volatility * dW;

          // Jump component (market crashes/rallies)
          if (Math.random() < jumpIntensity * dt) {
            const jumpSize = jumpMean + jumpStd * (Math.random() - 0.5) * 2;
            dS += jumpSize;
          }

          signal.push(signal[t - 1] + dS);
        }

        // Add some volatility clustering
        for (let t = 1; t < signalLength; t++) {
          const volCluster =
            0.1 * Math.abs(signal[t - 1] - (signal[t - 2] || 0));
          signal[t] += (Math.random() - 0.5) * volCluster;
        }

        signalComponents = [
          { name: "Random Walk + Drift", rate: drift.toFixed(3) },
          {
            name: "Jump Events",
            intensity: `${(jumpIntensity * 100).toFixed(1)}%`,
          },
          { name: "Vol Clustering", level: volatility.toFixed(2) },
          { name: "Base Noise", level: noiseLevel.toFixed(2) },
        ];

        updateSignalDisplay();
      }

      function updateSignalDisplay() {
        drawSignal();
        updateComponentsDisplay();
      }

      function updateComponentsDisplay() {
        const container = document.getElementById("signalComponents");
        container.innerHTML =
          '<div style="text-align: center; font-weight: bold; margin-bottom: 10px;">Signal Components:</div>';

        signalComponents.forEach((comp) => {
          const div = document.createElement("div");
          div.className = "component";

          let detail = "";
          if (comp.strength) detail = `Strength: ${comp.strength}`;
          else if (comp.freq) detail = `Freq: ${comp.freq}`;
          else if (comp.level) detail = `Level: ${comp.level}`;
          else if (comp.rate) detail = `Rate: ${comp.rate}`;
          else if (comp.detail) detail = comp.detail;

          div.innerHTML = `
                    <span class="component-name">${comp.name}</span>
                    <span>${detail}</span>
                `;
          container.appendChild(div);
        });
      }

      function drawSignal() {
        signalCtx.clearRect(0, 0, signalCanvas.width, signalCanvas.height);

        if (signal.length === 0) return;

        const margin = 30;
        const width = signalCanvas.width - 2 * margin;
        const height = signalCanvas.height - 2 * margin;

        // Convert signal to realistic daily revenue range ($5k-25k)
        const baseRevenue = 15000; // $15k baseline
        const revenueScale = 2000; // Scale factor
        const revenueSignal = signal.map(val => baseRevenue + (val * revenueScale));

        // Find range for revenue display
        const minVal = Math.min(...revenueSignal);
        const maxVal = Math.max(...revenueSignal);
        const range = maxVal - minVal || 1;

        // Helper functions
        const toX = (i) => margin + (i / (signal.length - 1)) * width;
        const toY = (val) =>
          margin + height - ((val - minVal) / range) * height;

        // Draw grid
        signalCtx.strokeStyle = "rgba(255,255,255,0.2)";
        signalCtx.lineWidth = 1;
        for (let i = 0; i <= 5; i++) {
          const y = margin + (i / 5) * height;
          signalCtx.beginPath();
          signalCtx.moveTo(margin, y);
          signalCtx.lineTo(margin + width, y);
          signalCtx.stroke();
        }

        // Draw signal using revenue values
        signalCtx.strokeStyle = "#4ECDC4";
        signalCtx.lineWidth = 2;
        signalCtx.beginPath();
        signalCtx.moveTo(toX(0), toY(revenueSignal[0]));
        for (let i = 1; i < revenueSignal.length; i++) {
          signalCtx.lineTo(toX(i), toY(revenueSignal[i]));
        }
        signalCtx.stroke();

        // Add Y-axis labels with dollar amounts
        signalCtx.fillStyle = "rgba(255,255,255,0.8)";
        signalCtx.font = "10px Arial";
        signalCtx.textAlign = "right";
        for (let i = 0; i <= 4; i++) {
          const yPos = margin + (i / 4) * height;
          const dollarValue = maxVal - (i / 4) * range;
          signalCtx.fillText(`$${(dollarValue/1000).toFixed(0)}k`, margin - 10, yPos + 3);
        }

        // Labels
        signalCtx.fillStyle = "white";
        signalCtx.font = "12px Arial";
        signalCtx.textAlign = "center";
        signalCtx.fillText(
          "Time ‚Üí",
          signalCanvas.width / 2,
          signalCanvas.height - 5
        );
        signalCtx.save();
        signalCtx.translate(15, signalCanvas.height / 2);
        signalCtx.rotate(-Math.PI / 2);
        signalCtx.fillText("Daily Revenue ($)", 0, 0);
        signalCtx.restore();
      }

      function fitARModel() {
        if (signal.length < arOrder + 1) {
          alert("Signal too short for AR order");
          return;
        }

        // Build design matrix and target vector using Yule-Walker
        const n = signal.length - arOrder;
        const X = [];
        const y = [];

        for (let t = arOrder; t < signal.length; t++) {
          const row = [];
          for (let lag = 1; lag <= arOrder; lag++) {
            row.push(signal[t - lag]);
          }
          X.push(row);
          y.push(signal[t]);
        }

        // Solve normal equations: (X'X)œÜ = X'y
        kernel = solveNormalEquations(X, y);

        // Generate predictions and calculate errors
        predictions = new Array(signal.length).fill(0);
        errors = new Array(signal.length).fill(0);

        // Make predictions for the training period
        let totalError = 0;
        let errorCount = 0;

        for (let t = arOrder; t < signal.length; t++) {
          let pred = 0;
          for (let lag = 1; lag <= arOrder; lag++) {
            pred += kernel[lag - 1] * signal[t - lag];
          }
          predictions[t] = pred;
          errors[t] = signal[t] - pred;
          totalError += errors[t] * errors[t];
          errorCount++;
        }

        const mse = errorCount > 0 ? totalError / errorCount : 0;

        updateKernelDisplay(mse);
      }

      function solveNormalEquations(X, y) {
        // Simple implementation of (X'X)^-1 X'y
        const p = X[0].length;
        const n = X.length;

        // Compute X'X
        const XTX = Array(p)
          .fill()
          .map(() => Array(p).fill(0));
        for (let i = 0; i < p; i++) {
          for (let j = 0; j < p; j++) {
            for (let k = 0; k < n; k++) {
              XTX[i][j] += X[k][i] * X[k][j];
            }
          }
        }

        // Compute X'y
        const XTy = Array(p).fill(0);
        for (let i = 0; i < p; i++) {
          for (let k = 0; k < n; k++) {
            XTy[i] += X[k][i] * y[k];
          }
        }

        // Solve using Gaussian elimination (simplified)
        return gaussianElimination(XTX, XTy);
      }

      function gaussianElimination(A, b) {
        const n = A.length;

        // Forward elimination
        for (let i = 0; i < n; i++) {
          // Find pivot
          let maxRow = i;
          for (let k = i + 1; k < n; k++) {
            if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) {
              maxRow = k;
            }
          }

          // Swap rows
          [A[i], A[maxRow]] = [A[maxRow], A[i]];
          [b[i], b[maxRow]] = [b[maxRow], b[i]];

          // Make all rows below this one 0 in current column
          for (let k = i + 1; k < n; k++) {
            if (Math.abs(A[i][i]) < 1e-10) continue; // Skip if pivot is too small
            const c = A[k][i] / A[i][i];
            for (let j = i; j < n; j++) {
              A[k][j] -= c * A[i][j];
            }
            b[k] -= c * b[i];
          }
        }

        // Back substitution
        const x = new Array(n).fill(0);
        for (let i = n - 1; i >= 0; i--) {
          x[i] = b[i];
          for (let j = i + 1; j < n; j++) {
            x[i] -= A[i][j] * x[j];
          }
          if (Math.abs(A[i][i]) > 1e-10) {
            x[i] /= A[i][i];
          }
        }

        return x;
      }

      function updateKernelDisplay(mse) {
        drawKernel();
        drawPredictions();
        drawErrors();
        // drawResponses(); // Removed - too technical for MBA audience

        // Update metrics with business-friendly format
        const dollarsRMSE = Math.sqrt(mse) * 2000; // Convert to dollar RMSE
        document.getElementById("mseValue").textContent = `¬±$${dollarsRMSE.toFixed(0)}`;

        // Classify kernel type
        const early = kernel
          .slice(0, Math.floor(arOrder / 3))
          .reduce((a, b) => a + Math.abs(b), 0);
        const late = kernel
          .slice(Math.floor((arOrder * 2) / 3))
          .reduce((a, b) => a + Math.abs(b), 0);
        const hasOscillation = kernel.some(
          (x, i) => i > 0 && Math.sign(x) !== Math.sign(kernel[i - 1])
        );

        let kernelType = "Focus: Balanced";
        if (early > late * 1.5) kernelType = "Focus: Recent Trends";
        else if (late > early * 1.5) kernelType = "Focus: Long-Term Average";
        else if (hasOscillation) kernelType = "Focus: Cyclical Patterns";

        document.getElementById("kernelType").textContent = kernelType;
      }

      function drawKernel() {
        kernelCtx.clearRect(0, 0, kernelCanvas.width, kernelCanvas.height);

        if (kernel.length === 0) return;

        const margin = 40;
        const width = kernelCanvas.width - 2 * margin;
        const height = kernelCanvas.height - 2 * margin;

        const maxAbs = Math.max(...kernel.map(Math.abs), 0.1);
        const scale = height / (2 * maxAbs);
        const zeroY = margin + height / 2;

        // Draw zero line
        kernelCtx.strokeStyle = "rgba(255,255,255,0.3)";
        kernelCtx.lineWidth = 1;
        kernelCtx.beginPath();
        kernelCtx.moveTo(margin, zeroY);
        kernelCtx.lineTo(margin + width, zeroY);
        kernelCtx.stroke();

        // Draw kernel coefficients
        const barWidth = width / arOrder;
        for (let i = 0; i < arOrder; i++) {
          const x = margin + i * barWidth;
          const barHeight = kernel[i] * scale;
          const y = zeroY - barHeight;

          // Color based on value
          const hue = kernel[i] > 0 ? 120 : 0;
          const saturation = 70;
          const lightness = 50 + (Math.abs(kernel[i]) / maxAbs) * 30;
          kernelCtx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

          kernelCtx.fillRect(
            x + 2,
            Math.min(y, zeroY),
            barWidth - 4,
            Math.abs(barHeight)
          );

          // Value label
          kernelCtx.fillStyle = "white";
          kernelCtx.font = "10px Arial";
          kernelCtx.textAlign = "center";
          kernelCtx.fillText(
            `${i + 1}`,
            x + barWidth / 2,
            margin + height + 15
          );

          // Coefficient value
          kernelCtx.fillText(
            `${kernel[i].toFixed(2)}`,
            x + barWidth / 2,
            y < zeroY ? y - 5 : y + 15
          );
        }

        // Labels
        kernelCtx.fillStyle = "white";
        kernelCtx.font = "12px Arial";
        kernelCtx.textAlign = "center";
        kernelCtx.fillText(
          "Lag Index ‚Üí",
          kernelCanvas.width / 2,
          kernelCanvas.height - 5
        );
      }

      // Removed drawResponses function - too technical for MBA audience

      // Removed drawImpulseResponse and drawFrequencyResponse functions - too technical for MBA audience

      function updateSliders() {
        document.getElementById("trendStrength").value = trendStrength;
        document.getElementById("trendValue").textContent =
          trendStrength.toFixed(1);

        document.getElementById("lowFreq").value = lowFreq;
        document.getElementById("lowFreqValue").textContent =
          lowFreq.toFixed(3);

        document.getElementById("midFreq").value = midFreq;
        document.getElementById("midFreqValue").textContent =
          midFreq.toFixed(3);

        document.getElementById("highFreq").value = highFreq;
        document.getElementById("highFreqValue").textContent =
          highFreq.toFixed(3);

        document.getElementById("logComponent").value = logComponent;
        document.getElementById("logValue").textContent =
          logComponent.toFixed(1);

        document.getElementById("noiseLevel").value = noiseLevel;
        document.getElementById("noiseValue").textContent =
          noiseLevel.toFixed(2);
      }

      // Event listeners
      document.getElementById("arOrder").addEventListener("input", (e) => {
        arOrder = parseInt(e.target.value);
        document.getElementById("arOrderValue").textContent = arOrder;
      });

      document.getElementById("signalLength").addEventListener("input", (e) => {
        signalLength = parseInt(e.target.value);
        document.getElementById("lengthValue").textContent = signalLength;
        generateSignal();
      });

      document.getElementById("noiseLevel").addEventListener("input", (e) => {
        noiseLevel = parseFloat(e.target.value);
        document.getElementById("noiseValue").textContent =
          noiseLevel.toFixed(2);
        generateSignal();
      });

      document
        .getElementById("trendStrength")
        .addEventListener("input", (e) => {
          trendStrength = parseFloat(e.target.value);
          document.getElementById("trendValue").textContent =
            trendStrength.toFixed(1);
          generateSignal();
        });

      document.getElementById("lowFreq").addEventListener("input", (e) => {
        lowFreq = parseFloat(e.target.value);
        document.getElementById("lowFreqValue").textContent =
          lowFreq.toFixed(3);
        generateSignal();
      });

      document.getElementById("midFreq").addEventListener("input", (e) => {
        midFreq = parseFloat(e.target.value);
        document.getElementById("midFreqValue").textContent =
          midFreq.toFixed(3);
        generateSignal();
      });

      document.getElementById("highFreq").addEventListener("input", (e) => {
        highFreq = parseFloat(e.target.value);
        document.getElementById("highFreqValue").textContent =
          highFreq.toFixed(3);
        generateSignal();
      });

      document.getElementById("logComponent").addEventListener("input", (e) => {
        logComponent = parseFloat(e.target.value);
        document.getElementById("logValue").textContent =
          logComponent.toFixed(1);
        generateSignal();
      });

      // Initialize - show data immediately
      generateSignal();

      // Also auto-train a model so user sees something immediately
      setTimeout(() => {
        fitARModel();
      }, 500);

      function drawPredictions() {
        predictionCtx.clearRect(
          0,
          0,
          predictionCanvas.width,
          predictionCanvas.height
        );

        if (predictions.length === 0) return;

        const margin = 30;
        const width = predictionCanvas.width - 2 * margin;
        const height = predictionCanvas.height - 2 * margin;

        // Find range for both signal and predictions
        const validPredictions = predictions.filter((p) => p !== 0);
        if (validPredictions.length === 0) return;

        const allValues = [...signal, ...validPredictions];
        const minVal = Math.min(...allValues);
        const maxVal = Math.max(...allValues);
        const range = maxVal - minVal || 1;

        // Helper functions
        const toX = (i) => margin + (i / (signal.length - 1)) * width;
        const toY = (val) =>
          margin + height - ((val - minVal) / range) * height;

        // Draw grid
        predictionCtx.strokeStyle = "rgba(255,255,255,0.2)";
        predictionCtx.lineWidth = 1;
        for (let i = 0; i <= 5; i++) {
          const y = margin + (i / 5) * height;
          predictionCtx.beginPath();
          predictionCtx.moveTo(margin, y);
          predictionCtx.lineTo(margin + width, y);
          predictionCtx.stroke();
        }

        // Draw actual signal
        predictionCtx.strokeStyle = "#4ECDC4";
        predictionCtx.lineWidth = 2;
        predictionCtx.beginPath();
        predictionCtx.moveTo(toX(0), toY(signal[0]));
        for (let i = 1; i < signal.length; i++) {
          predictionCtx.lineTo(toX(i), toY(signal[i]));
        }
        predictionCtx.stroke();

        // Draw predictions (only where they exist)
        predictionCtx.strokeStyle = "#FF6B6B";
        predictionCtx.lineWidth = 2;
        predictionCtx.setLineDash([5, 5]);
        predictionCtx.beginPath();

        let firstPred = true;
        for (let i = arOrder; i < predictions.length; i++) {
          if (predictions[i] !== 0) {
            // Shift prediction display to the left by 1 time step for visual alignment
            const x = toX(Math.max(0, i - 1));
            const y = toY(predictions[i]);
            if (firstPred) {
              predictionCtx.moveTo(x, y);
              firstPred = false;
            } else {
              predictionCtx.lineTo(x, y);
            }
          }
        }
        predictionCtx.stroke();
        predictionCtx.setLineDash([]);

        // Draw training region indicator
        const trainStartX = toX(arOrder);
        predictionCtx.strokeStyle = "rgba(255,255,255,0.4)";
        predictionCtx.lineWidth = 1;
        predictionCtx.setLineDash([2, 2]);
        predictionCtx.beginPath();
        predictionCtx.moveTo(trainStartX, margin);
        predictionCtx.lineTo(trainStartX, margin + height);
        predictionCtx.stroke();
        predictionCtx.setLineDash([]);

        // Labels - spread them out to avoid overlap
        predictionCtx.fillStyle = "#4ECDC4";
        predictionCtx.font = "12px Arial";
        predictionCtx.textAlign = "left";
        predictionCtx.fillText("Actual Market Prices", margin + 10, margin + 15);
        predictionCtx.fillStyle = "#FF6B6B";
        predictionCtx.fillText("Forecast Predictions", margin + 200, margin + 15);
        predictionCtx.fillStyle = "rgba(255,255,255,0.7)";
        predictionCtx.fillText(
          "Training Region ‚Üí",
          trainStartX + 5,
          margin + 35
        );
      }

      function drawErrors() {
        errorCtx.clearRect(0, 0, errorCanvas.width, errorCanvas.height);

        if (errors.length === 0) return;

        const margin = 30;
        const width = errorCanvas.width - 2 * margin;
        const height = errorCanvas.height - 2 * margin;

        // Get valid errors (non-zero)
        const validErrors = errors.slice(arOrder);
        if (validErrors.length === 0) return;

        const maxError = Math.max(...validErrors.map(Math.abs));
        const scale = height / (2 * (maxError || 1));
        const zeroY = margin + height / 2;

        // Draw zero line
        errorCtx.strokeStyle = "rgba(255,255,255,0.3)";
        errorCtx.lineWidth = 1;
        errorCtx.beginPath();
        errorCtx.moveTo(margin, zeroY);
        errorCtx.lineTo(margin + width, zeroY);
        errorCtx.stroke();

        // Draw error bars
        const barWidth = width / validErrors.length;
        for (let i = 0; i < validErrors.length; i++) {
          const x = margin + i * barWidth;
          const error = validErrors[i];
          const barHeight = error * scale;
          const y = zeroY - barHeight;

          // Color based on error magnitude
          const intensity = Math.abs(error) / maxError;
          const hue = error > 0 ? 0 : 240; // Red for positive, blue for negative
          const saturation = 70;
          const lightness = 50 + intensity * 30;
          errorCtx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

          errorCtx.fillRect(
            x,
            Math.min(y, zeroY),
            Math.max(barWidth * 0.8, 1),
            Math.abs(barHeight)
          );
        }

        // Draw error line
        errorCtx.strokeStyle = "#FFD93D";
        errorCtx.lineWidth = 2;
        errorCtx.beginPath();
        for (let i = 0; i < validErrors.length; i++) {
          const x = margin + i * barWidth + barWidth / 2;
          const y = zeroY - validErrors[i] * scale;
          if (i === 0) errorCtx.moveTo(x, y);
          else errorCtx.lineTo(x, y);
        }
        errorCtx.stroke();

        // Calculate and display error statistics
        const meanError =
          validErrors.reduce((a, b) => a + b, 0) / validErrors.length;
        const stdError = Math.sqrt(
          validErrors.reduce((sum, e) => sum + (e - meanError) ** 2, 0) /
            validErrors.length
        );
        const maxAbsError = Math.max(...validErrors.map(Math.abs));

        // Convert to realistic daily store revenue ($5k-25k range)
        const baseRevenue = 15000; // $15k baseline daily revenue
        const revenueScale = 2000; // Scale factor to get realistic range

        const dollarMeanError = Math.abs(meanError * revenueScale);
        const dollarStdError = stdError * revenueScale;
        const dollarMaxError = maxAbsError * revenueScale;

        // Labels and stats
        errorCtx.fillStyle = "white";
        errorCtx.font = "12px Arial";
        errorCtx.textAlign = "left";
        errorCtx.fillText(
          "Forecasting Errors: How Much Money Are We Off?",
          margin + 10,
          margin + 15
        );
        errorCtx.font = "11px Arial";
        errorCtx.fillText(
          `Avg Error: $${dollarMeanError.toFixed(2)}`,
          margin + 10,
          margin + height - 35
        );
        errorCtx.fillText(
          `Typical Range: ¬±$${dollarStdError.toFixed(2)}`,
          margin + 140,
          margin + height - 35
        );
        errorCtx.fillText(
          `Worst Error: $${dollarMaxError.toFixed(2)}`,
          margin + 320,
          margin + height - 35
        );

        // Add business interpretation
        errorCtx.fillStyle = "#FFD93D";
        errorCtx.font = "10px Arial";
        const totalDollarImpact = dollarMeanError * validErrors.length;
        errorCtx.fillText(
          `Total Impact: $${totalDollarImpact.toFixed(0)} over ${validErrors.length} periods`,
          margin + 10,
          margin + height - 15
        );

        // Check for patterns in residuals
        let autocorr = 0;
        for (let i = 1; i < validErrors.length; i++) {
          autocorr += validErrors[i] * validErrors[i - 1];
        }
        autocorr /= validErrors.length - 1;

        errorCtx.fillText(
          `AutoCorr: ${autocorr.toFixed(3)}`,
          margin + 260,
          margin + height - 30
        );
        if (Math.abs(autocorr) > 0.1) {
          errorCtx.fillStyle = "#FF6B6B";
          errorCtx.fillText(
            "(Residuals show pattern!)",
            margin + 350,
            margin + height - 30
          );
        }
      }

      // Global variables for generalization testing
      let originalTrainingMSE = 0;
      let currentPreset = 'trend'; // Track current preset

      function generateBusinessTakeaway(params, modelFocus, errorAmount, futureProofScore) {
        // Determine market type based on parameters
        let marketType = "Stable Market";
        if (params.trendStrength > 1.0) marketType = "High-Growth Market";
        else if (params.trendStrength > 0.5) marketType = "Trending Market";
        else if (params.lowFreq > 0.1 || params.midFreq > 0.2) marketType = "Cyclical Market";
        else if (params.noiseLevel > 0.3) marketType = "Highly Volatile Market";

        // Determine reliability
        let reliability = "";
        let reliabilityColor = "";
        if (futureProofScore < 1.5) {
          reliability = "reliable";
          reliabilityColor = "#4CAF50";
        } else if (futureProofScore < 2.5) {
          reliability = "moderately reliable";
          reliabilityColor = "#FF9800";
        } else {
          reliability = "unreliable";
          reliabilityColor = "#f44336";
        }

        // Generate takeaway message
        let takeaway = `<strong>Takeaway:</strong> You trained a model during a <span style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; font-weight: bold;">${marketType}</span>. `;
        takeaway += `Its strategy was to <span style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; font-weight: bold;">${modelFocus}</span>. `;
        takeaway += `When tested on new data, its average error was <span style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; font-weight: bold;">¬±$${errorAmount.toFixed(0)}</span>. `;
        takeaway += `The Future-Proof score of <span style="color: ${reliabilityColor}; font-weight: bold;">${futureProofScore.toFixed(1)}</span> shows this is a <span style="color: ${reliabilityColor}; font-weight: bold;">${reliability}</span> strategy for this type of market.`;

        // Add business interpretation
        if (futureProofScore >= 2.5) {
          takeaway += `<br><br><span style="color: #ffeb3b; font-weight: bold;">‚ö†Ô∏è Warning:</span> This model is overfit and would not be trusted for real business decisions. Consider reducing model complexity or gathering more training data.`;
        } else if (futureProofScore < 1.5) {
          takeaway += `<br><br><span style="color: #4CAF50; font-weight: bold;">‚úÖ Recommendation:</span> This model is reliable and ready for deployment in similar business environments.`;
        }

        // Display the takeaway
        document.getElementById("takeawayContent").innerHTML = takeaway;
        document.getElementById("businessTakeaway").style.display = "block";
      }

      function testGeneralization() {
        if (kernel.length === 0) {
          alert("Please train a model first!");
          return;
        }

        // Store the learned kernel and original signal
        const learnedKernel = [...kernel];
        const originalSignal = [...signal];
        const originalPredictions = [...predictions];
        const originalErrors = [...errors];

        // Store current parameters to regenerate with same settings
        const params = {
          trendStrength: trendStrength,
          lowFreq: lowFreq,
          midFreq: midFreq,
          highFreq: highFreq,
          logComponent: logComponent,
          noiseLevel: noiseLevel,
          signalLength: signalLength
        };

        // Generate new test data with same parameters but different random seed
        generateSignal();
        const testSignal = [...signal];

        // Test the learned kernel on new data (no retraining!)
        const testPredictions = new Array(testSignal.length).fill(0);
        const testErrors = new Array(testSignal.length).fill(0);
        let testMSE = 0;
        let testCount = 0;

        // Apply learned kernel to test data
        for (let t = arOrder; t < testSignal.length; t++) {
          let pred = 0;
          for (let lag = 1; lag <= arOrder; lag++) {
            pred += learnedKernel[lag - 1] * testSignal[t - lag];
          }
          testPredictions[t] = pred;
          testErrors[t] = testSignal[t] - pred;
          testMSE += testErrors[t] * testErrors[t];
          testCount++;
        }

        const generalizationMSE = testCount > 0 ? testMSE / testCount : 0;
        const overfitRatio = originalTrainingMSE > 0 ? generalizationMSE / originalTrainingMSE : 0;

        // Update displays with test results
        predictions = testPredictions;
        errors = testErrors;

        // Draw the test results
        drawPredictions();
        drawErrors();

        // Update metrics display with business-friendly format
        const dollarsGenRMSE = Math.sqrt(generalizationMSE) * 2000;
        document.getElementById("genMSE").textContent = `¬±$${dollarsGenRMSE.toFixed(0)}`;
        document.getElementById("overfitRatio").textContent = overfitRatio.toFixed(2);
        document.getElementById("genMetric").style.display = "block";
        document.getElementById("ratioMetric").style.display = "block";

        // Add interpretation
        let interpretation = "";
        if (overfitRatio < 1.5) {
          interpretation = " (Good!)";
          document.getElementById("overfitRatio").style.color = "#4CAF50";
        } else if (overfitRatio < 2.5) {
          interpretation = " (OK)";
          document.getElementById("overfitRatio").style.color = "#FF9800";
        } else {
          interpretation = " (Overfitting!)";
          document.getElementById("overfitRatio").style.color = "#f44336";
        }
        document.getElementById("overfitRatio").textContent = overfitRatio.toFixed(2) + interpretation;

        // Log results to console for debugging
        console.log(`Training MSE: ${originalTrainingMSE.toFixed(4)}`);
        console.log(`Generalization MSE: ${generalizationMSE.toFixed(4)}`);
        console.log(`Overfitting ratio: ${overfitRatio.toFixed(2)}`);

        // Update view controls
        document.getElementById("testViewBtn").style.display = "block";
        document.getElementById("currentView").textContent = "Currently viewing: Test Data";

        // Store data for view switching
        window.testData = {
          signal: testSignal,
          predictions: testPredictions,
          errors: testErrors
        };
        window.trainingData = {
          signal: originalSignal,
          predictions: originalPredictions,
          errors: originalErrors
        };

        // Generate business takeaway
        generateBusinessTakeaway(params, kernelType, dollarsGenRMSE, overfitRatio);
      }

      // Update the existing fitARModel function to store training MSE
      const originalFitARModel = fitARModel;
      fitARModel = function() {
        originalFitARModel();

        // Store training MSE for comparison
        if (errors.length > 0) {
          let totalError = 0;
          let errorCount = 0;
          for (let t = arOrder; t < signal.length; t++) {
            if (errors[t] !== undefined) {
              totalError += errors[t] * errors[t];
              errorCount++;
            }
          }
          originalTrainingMSE = errorCount > 0 ? totalError / errorCount : 0;
        }

        // Show the test button after training
        document.getElementById("viewControls").style.display = "block";
      };

      // View switching functions
      function showTrainingView() {
        if (window.trainingData) {
          signal = window.trainingData.signal;
          predictions = window.trainingData.predictions;
          errors = window.trainingData.errors;

          drawSignal();
          drawPredictions();
          drawErrors();
          updateSignalDisplay();

          document.getElementById("currentView").textContent = "Currently viewing: Training Data";
        }
      }

      function showTestView() {
        if (window.testData) {
          signal = window.testData.signal;
          predictions = window.testData.predictions;
          errors = window.testData.errors;

          drawSignal();
          drawPredictions();
          drawErrors();
          updateSignalDisplay();

          document.getElementById("currentView").textContent = "Currently viewing: Test Data";
        }
      }
    </script>
  </body>
</html>
